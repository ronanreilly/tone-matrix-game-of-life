package demo{	import flash.display.Sprite;	import flash.events.Event;	import flash.events.MouseEvent;		import test.effects.Delay;	import test.poly.SimplePolySynthVoiceFactory;		import tonfall.core.Engine;	import tonfall.core.TimeConversion;	import tonfall.display.AbstractApplication;	import tonfall.prefab.poly.PolySynth;	/**	 * Simple implementation of the Tonematrix	 * http://lab.andre-michelle.com/tonematrix	 * @author Andre Michelle	 */	 	 /*		Modified By Ronan Reilly, N00090333, DL131,		3rd Year Computing in Multimedia Programming,		Multimedia Programming II,		CA 1, Conways Game of Life,		November 2011			*/		/*		CLASS DESCRIPTION BELOW:			This class implements the ToneMatrix. For this assignment we have been asked		to implement some functions in this class to control the ToneMatrix. This class handles		events dispatched to it by ControlPanel.			*/	 	[SWF(backgroundColor="#FFF", frameRate="31", width="700", height="700")]	public final class DemoToneMatrix extends AbstractApplication	{		private var sequencer : TonematrixSequencer = new TonematrixSequencer();		private var generator : PolySynth = new PolySynth( SimplePolySynthVoiceFactory.INSTANCE );		private var delay: Delay = new Delay(TimeConversion.barsToMillis(8/16, Engine.getInstance().bpm));				// This vector is used to contain all of the buttons in the ToneMatrix.		// A vector is used so we can access each individual button in the Matrix.		// Creates sixteen storage containers with potential of putting in sixteen other vectors		// but empty as of this declaration.		private var _buttons: Vector.<Vector.<Button>> = new Vector.<Vector.<Button>>(16,true);				private var _container: Sprite;		private var _selectMode: Boolean;				// An variable for an instance of the Control Panel Class.		private var _controlPanel:ControlPanel;				// Constructor for this class initialise the view 		// and audio for the matrix.		public function DemoToneMatrix()		{			initView();			initAudio();			engine.bpm = 0;			//initAudio();		}				// Sets up the classes to be ready to process sound.		private function initAudio() : void		{			engine.processors.push( sequencer ); // Sets up the sequence of sounds.			engine.processors.push( generator ); // Music Sound			engine.processors.push( delay ); // Delay for the sounds is set up.			delay.signalInput = generator.signalOutput;			sequencer.receiver = generator;			engine.input = delay.signalOutput;		}				// This function initialises the view for the tone matrix.		// Inside this function an instance of the ControlPanel 		// class is craeted and events listeners are added to it.		private function initView() : void		{			// Creating a 2D vector that will contain Button objects			for(var i: int = 0 ; i < 16 ; i++) {				_buttons[i] = new Vector.<Button>(16, true);			}							_container = new Sprite();				_container.x = 128;				_container.y = 128;				 addChild( _container );						 for( var u: int = 0 ; u < 16 ; ++u )			 {				for( var v: int = 0 ; v < 16 ; ++v )				{					var button: Button = new Button( u, v );						// Putting our buttons into the vector _buttons					_buttons[u][v] = button;					button.x = ( u << 5 );					button.y = ( v << 5 );					_container.addChild( button );				}			}			// trace (_buttons);			addEventListener( MouseEvent.MOUSE_DOWN, mouseDown );			addEventListener( MouseEvent.MOUSE_MOVE, mouseMove );						// An Instance of the ControlPanel class is created and added to the 			// Matrix.						_controlPanel = new ControlPanel();			_controlPanel.x=-150;			_controlPanel.y=50;			addChild(_controlPanel);						// Event Listeners are added to the control panel.			// These event listeners listen out for interactions with ui			// components in the ControlPanel class. When a ui component is			// interacted with by the user an event is dispatched by its handler.			// These listeners wait for those events and act if the string passed 			// is the same as the value of the corresponding constant from the			// ControlPanel class.						_controlPanel.addEventListener(_controlPanel.CP_STARTAUDIO, startAudio, false, 0, true);			_controlPanel.addEventListener(_controlPanel.CP_STOPAUDIO, stopAudio, false, 0, true);			_controlPanel.addEventListener(_controlPanel.CP_RANDOM, randomise, false, 0, true);			_controlPanel.addEventListener(_controlPanel.CP_SCALEUP, scaleUp, false, 0, true);			_controlPanel.addEventListener(_controlPanel.CP_SCALEDOWN, scaleDown, false, 0, true);			_controlPanel.addEventListener(_controlPanel.CP_CLEAR, clearTheMatrix, false, 0, true);			_controlPanel.addEventListener(_controlPanel.CP_MYGOL, settingUpGameOfLife, false, 0, true);			_controlPanel.addEventListener(_controlPanel.CP_STOPMYGOL, stopGameOfLife, false, 0, true);			_controlPanel.addEventListener(_controlPanel.CP_BPM_SLIDER, changeTheBPM, false, 0, true);			_controlPanel.addEventListener(_controlPanel.CP_HIGHERNOTES, changeTheNotes, false, 0, true);			_controlPanel.addEventListener(_controlPanel.CP_NORMALNOTES, normalNotesAgain, false, 0, true);					}				// The event for this function is called from the		// control panel's stop audio button. Its sets the engines		// bpm to 0.				private function stopAudio(evt:Event) : void		{			engine.bpm=0;		}				// The event for this function is called from the		// control panel's start audio button. Its sets the engines		// bpm to the default value of the control panels bpm controller		// slider.				private function startAudio(evt:Event):void{			engine.bpm = _controlPanel.bpm;		}				private function startAudioInside():void{			engine.bpm = _controlPanel.bpm;		}						// The event for this function is called from the		// control panel's higher notes button. It		// changes the notes in the vector ToneMatrixNotes to an octave 		// higher than those that were originally loaded into the sequencer		// when the main class runs this ToneMatrix.  		// Getters and setters for this can be found at the end of 		// TonematrixSequencer class.				private function changeTheNotes(evt:Event):void{			// Array that stores the notes to be loaded into the sequencer			var a:Array = [104,101,99,97,94,92,89,87,85,82,80,77,75,73,70,68];			// This loop loops through the vector in teh sequncer and adds a note			// from the array a at each iteration until the loop gets to the 			// end of the sequencers ToneMatrixNotes vector.			for(var i:int=0; i < sequencer.ToneMatrixNotes.length; i++){				sequencer.ToneMatrixNotes[i] = a[i];			}		}				// This function is exactly the same as the above function except that 		// it puts the notes that were originally in the matrix when this class		// is called from the main class.				private function normalNotesAgain(evt:Event):void{			var a:Array = [96,93,91,89,86,84,81,79,77,74,72,69,67,65,62,60] ;			for(var i:int=0; i < sequencer.ToneMatrixNotes.length; i++){				sequencer.ToneMatrixNotes[i] = a[i];			}		}				private function changePattern( u: int, v: int, value: Boolean ): void		{			sequencer.pattern[u][v] = value;		}				override protected function resize( event : Event = null ) : void		{			if( null != _container )			{				_container.x = ( stage.stageWidth  - 512 ) >> 1;				_container.y = ( stage.stageHeight - 512 ) >> 1;			}		}				private function mouseMove( event : MouseEvent ) : void		{			var button: Button = event.target as Button;						if( event.buttonDown && null != button )			{				button.selected = _selectMode;				changePattern( button.u, button.v, button.selected );			}		}				private function mouseDown( event : MouseEvent ) : void		{			var button: Button = event.target as Button;						if( null != button )			{				button.selected = _selectMode = !button.selected;								changePattern( button.u, button.v, button.selected );			}		}				// The event for this function is called from the		// control panel's randomise button. This function uses two loops an inner and an 		// outer too loop through the _buttons vector and set the 		// buttons selected state to selected randomly.				private function randomise(evt:Event):void {			sequencer.removeEventListener('EoS', endOfSequence);			trace('ControlPanel: ' + 'Randomise Matrix Event Executed');			var seed:Number = 0.85;			var bool:Boolean = false;			//var num:int = 0;			for(var i: int = 0 ; i < 16 ; i++) {				for(var j: int = 0 ; j < 16 ; j++) {					// Like an if statement, if the random we create is greater than seed, boolean is true, else false.					bool = (Math.random() > seed) ? true : false;					changePattern(i, j, bool);					_buttons[i][j].selected = bool;				}			}		}				// The event for this function is called from the		// control panel's scale up button. This function uses a loop		// to scale up the matrix from the bottom left corner button		// to the top right corner button in a diagonal.				private function scaleUp(evt:Event):void {			// This line esentially stops the game of life if it is running when 			// this function is called.			sequencer.removeEventListener('EoS', endOfSequence);			// This method clears the matrix before the scale up is run. 			clearTheMatrixFromInside();			trace('ControlPanel: ' + 'Scale Up Matrix Event Executed');			var l: int = 0;			for(var j: int = 15 ; j >= 0 ; j--) {				changePattern(l, j, true);				_buttons[l][j].selected = true;				l++;			}		}				// This function is the same as the above function except that it scales		// down the opposite direction to the scale up function.				private function scaleDown(evt:Event):void {			sequencer.removeEventListener('EoS', endOfSequence);			clearTheMatrixFromInside();			trace('ControlPanel: ' + 'Scale Down Matrix Event Executed');			for(var i: int = 0 ; i < 16 ; i++) {					changePattern(i, i, true);					_buttons[i][i].selected = true;			}		}				// The event for this function is called from the		// control panel's clear button. This function uses a loop		// to iterate throught teh -buttons vector and set teh selected status		// of all buttons inside it to false.				private function clearTheMatrix(evt:Event):void{		// Stops the game of life if it is running when this function is called			sequencer.removeEventListener('EoS', endOfSequence);			trace('ControlPanel: ' + 'Clear The Matrix Event Executed');			var bool:Boolean = false;			for(var i: int = 0 ; i < 16 ; i++) {				for(var j: int = 0 ; j < 16 ; j++) {					// Like an if statement, if the random we create is greater than seed, boolean is true, else false.					changePattern(i, j, bool);					_buttons[i][j].selected = bool;				}			}		}				// This function is exactly the same as the function above		// except it does not take an event. This means it can be 		// called by other functions inside this class without the 		// need for an event listener.				private function clearTheMatrixFromInside():void{			sequencer.removeEventListener('EoS', endOfSequence);			trace('ControlPanel: ' + 'Matrix Cleared From Inside');			var bool:Boolean = false;			//var num:int = 0;			for(var i: int = 0 ; i < 16 ; i++) {				for(var j: int = 0 ; j < 16 ; j++) {					// Like an if statement, if the random we create is greater than seed, boolean is true, else false.					changePattern(i, j, bool);					_buttons[i][j].selected = bool;				}			}		}				// The event for this function is called from the		// control panel's change bpm slider button. This function		// assigns the engines bpm to that of the value of the slider		// is currently set to using the bpm getter from the control		// panel class.				private function changeTheBPM(evt:Event):void{			engine.bpm = _controlPanel.bpm;		}				// The event for this function is called from the		// control panel's start game of life button. This function adds		// an event listener to the sequencer called end of sequence. 				private function settingUpGameOfLife(evt:Event):void{			sequencer.addEventListener('EoS', endOfSequence, false, 0, true);		}				// When the sequencer gets to the end of one bar		// this function is called, see the process function in the		// TonematrixSequencer class below. This function calls the 		// start game of life function.				private function endOfSequence(evt:Event):void {			startTheGameOfLife();		}				// The event for this function is called from the		// control panel's stop game of life button. This function removes		// an event listener to the sequencer called end of sequence, 		// so the game of life stops. 				private function stopGameOfLife(evt:Event):void{			sequencer.removeEventListener('EoS', endOfSequence);		}		/*			This startGameOfLife function performs a check on the four corner buttons,			the edge or border rows of buttons and the buttons inside the borders of the edge rows			(middle of the grid) in the _buttons vector. This check is performed inside a nested for loop to ensure that			every button in the 2-d vector is checked. Once the check on buttons has been carried out 			there are some small if statements that apply the game of life's rules depeneding			on the selected status of the button being checked. A for loop is then used at the end of the method to 			change the selected status of each button accordingly in the 2-d vector . 		*/		public function startTheGameOfLife():void		{			trace('ControlPanel: ' + 'Play GOL in Matrix Event Executed');			var temp:int=0;			var xLength:int = 15;			var yLength:int = 15;			var button:Button;			var x:int;			var y:int;						for (x=0; x < 16; x++)			{				for(y= 0; y < 16; y++ )				{					// setting a refernece to a button to the buttons in 					// the array _buttons x and y position					button = _buttons[x][y];								// Checks the top left corner button.					if (x==0 && y==0)					{    						temp =							_buttons[x+1][y].selected +//East button							_buttons[x+1][y+1].selected +//SoutEast button							_buttons[x][y+1].selected;//South button					 }					 // Checks the top right corner button.					else if (x == xLength && y==0)					{						temp =							_buttons[x-1][y].selected +//West button							_buttons[x-1][y+1].selected +  //SoutWest button							_buttons[x][y+1].selected;//South button									}					// Checks the bottom right corner button.					else if (x == xLength && y == yLength)					{						temp = 							_buttons[x][y-1].selected +//North button							_buttons[x-1][y-1].selected +//NorthWest button							_buttons[x-1][y].selected;//West button					}					// Checks the bottom left corner button.					else if (x == 0 && y == yLength)					{						temp =							_buttons[x][y-1].selected +//North button							_buttons[x+1][y-1].selected +//NorthEast button							_buttons[x+1][y].selected;//East button					}					// Checks the top border of edge buttons.					else if (y == 0)					{						temp =							_buttons[x-1][y].selected +//West button							_buttons[x-1][y+1].selected +  //SoutWest button							_buttons[x][y+1].selected +//South button							_buttons[x+1][y+1].selected +//SoutEast button							_buttons[x+1][y].selected;//East button					}					// Checks the right border edge of buttons.					else if (x == xLength)					{						temp =							_buttons[x][y-1].selected +//North button							_buttons[x-1][y-1].selected +//NorthWest button							_buttons[x-1][y].selected +//West button							_buttons[x-1][y+1].selected +  //SoutWest button							_buttons[x][y+1].selected;//South button					}					// Checks the left border edge of buttons.					else if (x == 0)					{						temp =											_buttons[x][y-1].selected +//North button							_buttons[x+1][y-1].selected +//NorthEast button							_buttons[x+1][y].selected +//East button							_buttons[x+1][y+1].selected +//SoutEast button							_buttons[x][y+1].selected;//South button					}									// Checks the bottom border edge of buttons.					else if (y == yLength)					{						temp = 							_buttons[x-1][y].selected +//West button							_buttons[x-1][y-1].selected +//NorthWest button							_buttons[x][y-1].selected +//North button							_buttons[x+1][y-1].selected +//NorthEast button							_buttons[x+1][y].selected;//East button					}							// Checks all the middle buttons.					else					{						temp = 							_buttons[x][y-1].selected +//North button							_buttons[x][y+1].selected +//South button							_buttons[x+1][y].selected +//East button							_buttons[x-1][y].selected +//West button							_buttons[x-1][y-1].selected +//NorthWest button							_buttons[x+1][y-1].selected +//NorthEast button							_buttons[x+1][y+1].selected +//SoutEast button							_buttons[x-1][y+1].selected;  //SoutWest button					}										// Checks the first rule of the game of life					// button will die by lonliness.					if (button.selected == 1)					{						if(temp == 2 || temp == 3) button.nextStatus = true;						else button.nextStatus = false;					}					// Checks the second rule of the game of life					// button will die by overcrowding.					else {						if(temp == 3) button.nextStatus = true;						else button.nextStatus = false;					}					_buttons[x][y].nextStatus=button.nextStatus; // status here should be next,														 // problem with method is here???				} // end inner loop			} // end outer loop						for(x = 0; x < 16; x++) {					for(y = 0; y < 16; y++) {						// play the updated sound						changePattern(x, y, _buttons[x][y].nextStatus);						// update the button state						_buttons[x][y].selected = _buttons[x][y].nextStatus;					}				}			//generation++;		}	}}// This buttons class is similar to the tile class form the Game of Life// in the las CA.import tonfall.core.BlockInfo;import tonfall.core.Processor;import tonfall.core.TimeEventNote;import flash.display.Sprite;final class Button extends Sprite{	private var _u : int;	private var _v : int;		// If a button is selected or not.	private var _selected: Boolean;		// Next status for the game of life.	private var _nextStatus:Boolean;	public function Button( u : int, v : int )	{		_u = u;		_v = v;		update();	}	public function get u() : int	{		return _u;	}	public function get v() : int	{		return _v;	}	// Gets wheter button is selected	public function get selected() : Boolean	{		return _selected;	}	// Sets if button is selected	public function set selected( selected : Boolean ) : void	{		_selected = selected;		update();	}		// Getter for a buttons next status in the game of life function	public function get nextStatus() : Boolean	{		return _nextStatus;	}	// Setter for a buttons next status in the game of life function	public function set nextStatus( nextStatus : Boolean ) : void	{		_nextStatus = nextStatus;		// Redraw for wheter a button is selected or not		update();	}		private function update(): void	{		graphics.clear();		// Like an if then statement on one line, checks if this button is selected		graphics.beginFill( _selected ? 0x97ff10 : 0x666666 );		graphics.drawRoundRect( 2.0, 2.0, 30.0, 30.0, 6, 6 );		graphics.endFill();	}}import flash.events.Event;// Lines up all the note events and plays them in the right orderclass TonematrixSequencer extends Processor{	private var _ToneMatrixNotes : Vector.<int> = Vector.<int>( [96,93,91,89,86,84,81,79,77,74,72,69,67,65,62,60] );		// A grid or array of vectors that contains booleans	public const pattern: Vector.<Vector.<Boolean>> = new Vector.<Vector.<Boolean>>(16,true);		public var receiver: Processor;		public var localNumber:int;		public function TonematrixSequencer()	{		for(var i:int = 0 ;i <16;++i)		{			pattern[i] = new Vector.<Boolean>(16,true);		}			}		override public function process( info : BlockInfo ) : void	{		// Index is when a note has been played		//var ToneMatrixNotes : Vector.<int> = Vector.<int>( [96,93,91,89,86,84,81,79,77,74,72,69,67,65,62,60] );				var index: int = int( info.barFrom * 16.0 );		var position: Number = index / 16.0;				while( position < info.barTo )		{			if( position >= info.barFrom )			{					if((index % 16) == 15) {					//trace("End of sequence");					dispatchEvent(new Event("EoS"));				}				for( var i: int = 0 ; i < 16 ; ++i )				{					if(pattern[index%16][i])					{						var event: TimeEventNote = new TimeEventNote();						event.barPosition = position;						event.note = _ToneMatrixNotes[i];						event.barDuration = 1.0/16.0;						receiver.addTimeEvent(event);					}				}			}			position += 1.0/16.0;			++index;		}	}		// Getters and setters for the changing of notes in the 	// sequencers ToneMatrixNotes Vector.	public function set ToneMatrixNotes(arr:Vector.<int>):void{		_ToneMatrixNotes : arr;	}		public function get ToneMatrixNotes():Vector.<int>{		return _ToneMatrixNotes;	}}